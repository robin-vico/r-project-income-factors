---
title: "main"
author: "Robin VICO"
date: "2025-10-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Step 1: Data Cleaning and Preparation

```{r, include=FALSE}
library(tidyverse)
library(scales)
library(ggplot2)
library(dplyr)
```

```{r}
raw_data = read.csv('data/raw/adult.csv')
raw_data %>%
  head() %>%
  print()
```

```{r}
print(raw_data)
```

```{r}
raw_data %>%
  dim() %>%
  print()
```

```{r}
raw_data %>%
  colnames() %>%
  print()
```

```{r}
raw_data %>%
  str() %>%
  print()
```

```{r}
NA_values = raw_data %>%
  filter(workclass=='?'| occupation=='?'| native.country=='?') %>%
  print()
```

```{r}
print(dim(NA_values))
```

```{r}
for (col_name in names(raw_data)) {
  cat("Colonne :", col_name, "\n")
  print(sort(unique(raw_data[[col_name]])))
  cat("\n")
}
```

cleaning missing values in workclass column :

```{r}
raw_data %>%
  count(workclass) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)
```

we notice that the majority of the classes is 'private' -\> shall we set to 'private' all missing values ?

We can try to go further by looking at the most common workclass for each sex, country, age, education, education.num

```{r}
colnames(data)
```

```{r}
raw_data %>% 
  filter(workclass != '?', sex=='Male') %>% 
  count(workclass) %>%
  arrange(desc(n)) %>%
  print()
```

```{r}
raw_data %>% 
  filter(workclass != '?', sex=='Female') %>% 
  count(workclass) %>%
  arrange(desc(n)) %>%
  print()
```

```{r}
raw_data %>% 
  filter(workclass != '?') %>% 
  group_by(age, sex, education, native.country) %>%
  count(workclass) %>%
  arrange(desc(n)) %>%
  print()
```

For the moment we will just replace all the missing values by the most common value

```{r}
most_common_workclasses = raw_data %>%
  count(workclass) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)

most_common_workclass = most_common_workclasses$workclass[1]

cleaned_data = raw_data %>%
  mutate(workclass = recode(workclass, '?' = most_common_workclass))
head(cleaned_data)
```

```{r}
raw_data %>%
  count(occupation) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)
```

for the occupation column we see that there are no occupation that dominate the others, replacing all the missing values by the most common one is not really a good idea. For the moment we will simply drop the lines containing missing value for the occupation column.

```{r}
cleaned_data = cleaned_data %>%
  filter(occupation != '?')
```

```{r}
most_common_native_countries = raw_data %>%
  count(native.country) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)

print(head(most_common_native_countries))
```

```{r}
most_common_native_country = most_common_native_countries$native.country[1]
print(most_common_native_country)
```

for the missing values in the column native.country, we will replace them by the most common attribute, united-states since its the majority of the elements.

```{r}
cleaned_data = cleaned_data %>%
  mutate(native.country = recode(native.country, '?' = most_common_native_country))
head(cleaned_data)
```

Quick check to see if the difference between raw and cleaned data :

```{r}
print(raw_data)
```

```{r}
print(cleaned_data)
```

Summary : We replaced '?' values of workclass and native.country by the most common values of both columns and we dropped the lines containing '?' values in the column occupation.

Now, because we have two look-alike variables, education and education.num, let's check if there's any redundancy.

```{r}
education_check <- cleaned_data %>%
    select(education, education.num)%>%
    distinct() %>%
    arrange(education.num)
print(education_check)
```

After verification, we can confidently conclude that there is a perfect correlation and redundancy between the two variables. Therefore, it is not only acceptable but even preferable to exclude the education variable from our subsequent analysis.

Moreover, education is not the only variable that can be considered unnecessary. Based on our research, the fnlwgt (final weight) variable also does not contribute meaningfully to our predictive task. This variable represents the number of people in the surveyed population who share the same profile. Consequently, it does not help our models determine whether an individual is likely to earn more or less than \$50K per year.

```{r}
cleaned_data <- cleaned_data %>% 
  select(-fnlwgt, -education)
```

```{r}
print(cleaned_data)
```

Categorical variables : Some categorical variables may contain leading or trailing whitespace. Clean these columns.x

```{r}
library(dplyr)
library(stringr)

cols_with_whitespace <- cleaned_data %>%
  summarise(across(where(is.character), ~ any(str_detect(., "^\\s|\\s$"))))

cols_with_whitespace
```

as we see there is no column that contain any leading or trailing whitespace.

# Step 2: Feature Transformation and Engineering

```{r}
cleaned_data <- cleaned_data %>%
  mutate(native.country = ifelse(native.country == "United-States", "USA", "Other"))
  

print(cleaned_data)
```

```{r}
cleaned_data = cleaned_data %>%
  mutate(income = ifelse(income == '>50K', 1, 0))

print(cleaned_data)
```

```{r}
cleaned_data = cleaned_data %>%
  mutate(age.group = case_when(
    age >= 17 & age <= 20 ~ "Young",
    age >= 21 & age <= 59 ~ "Adult",
    age > 59 ~ "Senior",
  ))
print(cleaned_data)
```

```{r}
final_data = cleaned_data %>%
  mutate(net.capital = capital.gain - capital.loss) %>%
  select(-capital.gain, -capital.loss)

print(final_data)
```

# Step 3: Visualization and Exploration

```{r}
over_50k = final_data %>%
  filter(income == TRUE)
print(over_50k)
```

Income and Education Level : Visualize the proportion of people earning over \$50K for each level of education-num using a bar diagram

```{r}
ggplot(over_50k, aes(x = factor(education.num))) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Proportion of individuals earning > 50K by education level",
    x = "Education number (education.num)",
    y = "Proportion of individuals in the > 50K subset"
  )
```

Work Hours and Income: Compare the distribution of hours-per-week between the two income classes.

```{r}
data = final_data %>%
  mutate(income = factor(income, labels = c("<=50K", ">50K")))

ggplot(data, aes(x = hours.per.week, fill = income)) +
  geom_histogram(bins = 30) + 
  facet_wrap(~ income, scales = "free_y", ncol = 1) + 
  labs(
    title = "Distribution of hours per week, faceted by income class",
    x = "Hours per week",
    y = "Frequency (number of individuals)",
    fill = "Income class"
  )
```

Impact of Marital Status: Visualize the relationship between marital-status and income.

```{r}
sample_marital_status = data %>%
  select(marital.status, income)

ggplot(sample_marital_status, aes(x = marital.status, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = percent) +
  labs(
    title = "Impact of marital status on income",
    x = "Marital status",
    y = "Distribution of income class",
    fill = "Income class"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}
sample_age_distrib = data %>%
  select(age, income)

ggplot(sample_age_distrib, aes(x = age)) +
  geom_histogram(aes(fill = income), position = "identity") + 
  facet_wrap(~ income, scales = "free_y") + 
  labs(
    title = "Age distribution faceted by the income class",
    x = "Age",
    y = "Number of people",
    fill = "Income class"
  )
```

```{r}
ggplot(data, aes(x = relationship, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Proportion of income > 50K by family role/relationship",
    x = "Relationship",
    y = "Proportion of income category",
    fill = "Income level"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
ggplot(data, aes(x = marital.status, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  facet_wrap(~ sex) + 
  labs(
    title = "Proportion of income > 50K by marital status and sex",
    x = "Marital status",
    y = "Proportion of income category",
    fill = "Income level"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Supposons que votre variable groupée s'appelle 'native.country.grouped'
ggplot(data, aes(x = native.country, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Proportion of high income by native country (US vs other)",
    x = "Native country (grouped)",
    y = "Proportion of income category",
    fill = "Income level"
  )
```

```{r}
print(final_data)
write.csv(final_data,"data/processed/clean_v1.csv")
```


## IMPORTANT TO ADD TO main.Rmd UNTIL IT IS NOTIFIED Alternative Data Cleaning Approaches - 
Now that the data preparation is done as well as the visualisation , we can move on to the modeling but why test the model on only one type of cleaned data ? That's the question we asked ourselves. Let's test other ways to clean the data so you can compare afterhand.

Let's see what are the missing variables


```{r}
df=raw_data
na_summary <- sapply(df, function(x) sum(x == "?" | is.na(x)))
na_percentage <- na_summary / nrow(df) * 100
na_df <- data.frame(variable = names(na_percentage), pourcentage_NA = na_percentage)
print(na_df%>%filter(pourcentage_NA != 0))
```

The missing variables are occupation, workclass and native.country

```{r}

# Reusable function to plot categorical variable distribution with grouping of low-frequency categories
# - `col`: column name (quoted string) or unquoted symbol
# - `data`: data.frame containing the column
# - `max_categories`: number of top categories to keep (others grouped as 'Autres')
plot_categorical <- function(col, data, max_categories = 20) {
  # allow unquoted or quoted column name
  col_name <- if (is.character(col)) {
    col
  } else {
    deparse(substitute(col))
  }

  # validate data argument
  if (missing(data)) stop("`data` is missing; provide a data.frame as the second argument")
  if (is.function(data)) stop("`data` appears to be a function/closure; provide a data.frame named e.g. df")
  if (!is.data.frame(data)) stop("`data` must be a data.frame")

  if (!col_name %in% names(data)) stop(paste0("Column '", col_name, "' not found in data."))

  df_tmp <- data

  # ensure character and treat "?" as missing; keep NA label for plotting
  df_tmp[[col_name]] <- as.character(df_tmp[[col_name]])
  df_tmp[[col_name]][df_tmp[[col_name]] == "?"] <- NA_character_
  df_tmp[[col_name]][is.na(df_tmp[[col_name]])] <- "NA"

  # frequency table (including NA) and keep top categories
  counts_raw <- as.data.frame(table(df_tmp[[col_name]], useNA = "ifany"), stringsAsFactors = FALSE)
  colnames(counts_raw) <- c("valeur", "frequence")
  top_categories <- head(counts_raw[order(-counts_raw$frequence), "valeur"], max_categories)

  # group the rest into 'Autres'
  df_tmp[[col_name]] <- ifelse(df_tmp[[col_name]] %in% top_categories, df_tmp[[col_name]], "Autres")

  # recompute counts and percentages
  counts2 <- as.data.frame(table(df_tmp[[col_name]]), stringsAsFactors = FALSE)
  colnames(counts2) <- c("valeur", "frequence")
  counts2$pourcentage <- counts2$frequence / sum(counts2$frequence) * 100

  # order categories by percentage desc
  counts2$valeur <- factor(counts2$valeur, levels = counts2$valeur[order(-counts2$pourcentage)])

  # plot
  p <- ggplot(counts2, aes(x = valeur, y = pourcentage, fill = valeur)) +
    geom_col(show.legend = FALSE) +
    geom_text(aes(label = paste0(round(pourcentage, 1), "%")), vjust = -0.5, size = 3) +
    labs(title = paste("Répartition (pourcentage) de", col_name),
         x = col_name,
         y = "Pourcentage (%)") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ylim(0, max(counts2$pourcentage) * 1.12)

  print(p)
  invisible(counts2)
}
```

For the native.country, almost 90% of the population is from USA and the second single country is only at 2% so it make sense to add to the mass the ? cases.

```{r}
plot_categorical("native.country",df,10)

```

```{r}
df <- df %>% mutate(native.country = ifelse(native.country == "?", "United-States", native.country))
```

For the workclass, the results are more complex. even if there's the "private" category that contains more or less 70% of the total, there's still competitors around 6-7% by category.SO it could be intersting to do a bit of profiling.

```{r}
plot_categorical("workclass",df)
```

Let's analyze the workclass missing values according to other variables. for Sex:

```{r}
df %>%
  filter(!is.na(workclass)) %>%
  group_by(sex, workclass) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(sex) %>%
  mutate(percentage = count/sum(count)*100) %>%
  ggplot(aes(x = workclass, y = percentage, fill = sex)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Workclass", y = "Percentage", fill = "Sex") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

We can't really see a trend, the difference by workclass and by sex are not really significant.

now for Age:

```{r}
df %>%
  filter(!is.na(workclass)) %>%
  mutate(age_group = cut(age, 
                         breaks = c(-Inf, 25, 35, 45, 55, 65, Inf),
                         labels = c("<25", "25-35", "35-45", "45-55", "55-65", "65+"))) %>%
  group_by(age_group, workclass) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(age_group) %>%
  mutate(percentage = count/sum(count)*100) %>%
  ggplot(aes(x = workclass, y = percentage, fill = age_group)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Workclass", y = "Percentage", fill = "Age Group") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

we now know that a important portion of the missing workclass values are from old people (65+). More generally we see that age is strongly related to the workclass.The older you are , the less chance you have to be in "Private" workclass(80% for \<25 vs 40% for 65+). With this degre of correlation, the age parameter is a good candidate to help us fill the missing workclass values.Let's search for more

For the education.num parameter:

```{r}
df %>%
  filter(!is.na(workclass)) %>%
  group_by(education.num, workclass) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(education.num) %>%
  mutate(percentage = count/sum(count)*100) %>%
  ggplot(aes(x = workclass, y = percentage, fill = as.factor(education.num))) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Workclass", y = "Percentage", fill = "Education Num") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

From this graph we can conclude several things: 1.In terms of level of study, the missing class behaves pretty similarly to the private class which makes sense considering that the private class is the majority of the workclass. 2.The highly educated (14+) behaves quite differently making a huge part of these class: Local and state governments & self employed.

Let's keep digging for clues:

For marital status:

```{r}
df %>%
  filter(!is.na(workclass)) %>%
  group_by(marital.status, workclass) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(marital.status) %>%
  mutate(percentage = count/sum(count)*100) %>%
  ggplot(aes(x = workclass, y = percentage, fill = as.factor(marital.status))) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Workclass", y = "Percentage", fill = "Marital Status") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

seeing the graph, it seems the marital status doesn't really influence the workclass.

```{r}
df<-df %>%
  filter(!is.na(workclass)) %>%
  mutate(hpweek_group = cut(hours.per.week, 
                         breaks = c(-Inf, 10, 20, 30, 40, 50, 60 ,70, 80,90, Inf),
                         labels = c("<10", "10-20", "20-30", "30-40", "40-50", "50-60", "60-70" ,"70-80", "80-90", "90+"))) %>%
  group_by(hpweek_group, workclass) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(hpweek_group) %>%
  mutate(percentage = count/sum(count)*100) %>%
  ggplot(aes(x = workclass, y = percentage, fill = hpweek_group)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Workclass", y = "Percentage", fill = "hours per week Group") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Here we have a much more influenced graph. If we compare ti to the workclass histogramm we can see some obvious dipsarities such as: the high percentage of people working little(\<10) in the missing class and the high percentage working a lot(80+) in the self-employed not incorporated class. These spikes deforms the habitual chunk of the private class, showing real influence from the hours per week parameter.

To conclude on the workclass: it can be useful to fill the missing workclass to first profile each of it representative by age and hours per week. To do so, we first need to modify the dataset to turn the age and the hours.per.week into discrete variables by grouping them.

```{r}
df_modified = df
  mutate(age_group = cut(age, 
                         breaks = c(-Inf, 25, 35, 45, 55, 65, Inf),
                         labels = c("<25", "25-35", "35-45", "45-55", "55-65", "65+"))) %>%
  mutate(hpweek_group = cut(hours.per.week, 
                         breaks = c(-Inf, 10, 20, 30, 40, 50, 60 ,70, 80,90, Inf),
                         labels = c("<10", "10-20", "20-30", "30-40", "40-50", "50-60", "60-70" ,"70-80", "80-90", "90+")))
```
At this step of  the process, the goal is to gather some data on what are the dominant(higher frequence) workclass in each couple of age class and hour per week class.
```{r}
dominant_workclass <- df_modified %>%
  filter(workclass!="?")%>%
  group_by(workclass, age_group, hpweek_group) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(age_group, hpweek_group) %>%
  mutate(percentage = count / sum(count) * 100) %>%
  slice_max(order_by = percentage, n = 1, with_ties = FALSE) %>%
  ungroup()%>%
  print()

```


#check for age_group=="<25" & hpweek_group=="<10"
print(workclass_profile %>% arrange(age_group,hpweek_group,percentage))

Now we can use this profile to fill the missing workclass values according to the age_group and hpweek_group of each missing case.


```{r}
fill_workclass <- function(age_grp, hpweek_grp) {
  profile_workclass <- dominant_workclass %>%
    filter(age_group == age_grp, hpweek_group == hpweek_grp)%>%
    pull(workclass)
  
  return(ifelse(length(profile_workclass)==0,"Private",profile_workclass))
}

df_filled <- df_modified %>%
  rowwise() %>%
  mutate(workclass = ifelse(workclass == "?",
                            fill_workclass(age_group, hpweek_group),
                            workclass)) %>%
  ungroup()

```
After having successfully adressed the workclass issue, we now need to do the same for the "occupation" variable that's way more spread across its different class as we can see on the grah below
```{r}
plot_categorical("occupation",df)
```
Let's test how can the other variables influence on the occupation.Precision: we're now using a different fonction to graph the data because it was becoming difficult to see the influence between variables. We now graph the difference between the actual repartition of marital status over each occupation and the theorical repartition if ther was total independance between the two variables:occupation and marital status
```{r}

real_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(marital.status, occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(marital.status) %>%
  mutate(percentage = count/sum(count)*100)

reference_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percentage_ref = count/sum(count)*100)

diff_data <- real_dist %>%
  left_join(reference_dist %>% select(occupation, percentage_ref), 
            by = "occupation") %>%
  mutate(diff = percentage - percentage_ref)

ggplot(diff_data, aes(x = occupation, y = diff, fill = marital.status)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  labs(x = "Occupation", 
       y = "Difference (% reel - % theorical)", 
       fill = "Marital Status",
       title = "Distance from the variables Independance ") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

mean_diff_marital_status <- diff_data %>%
  group_by(marital.status) %>%
  summarise(ecart_moyen = mean(abs(diff))) %>%
  arrange(desc(ecart_moyen))
```
Let's check for age(discretised):

```{r}
df=df_modified

real_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(age_group, occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(age_group) %>%
  mutate(percentage = count/sum(count)*100)

reference_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percentage_ref = count/sum(count)*100)

diff_data <- real_dist %>%
  left_join(reference_dist %>% select(occupation, percentage_ref), 
            by = "occupation") %>%
  mutate(diff = percentage - percentage_ref)

ggplot(diff_data, aes(x = occupation, y = diff, fill = age_group)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  labs(x = "Occupation", 
       y = "Difference (% reel - % theorical)", 
       fill = "age group",
       title = "Distance from the variables Independance ") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

mean_diff_age_group <- diff_data %>%
  group_by(age_group) %>%
  summarise(ecart_moyen = mean(abs(diff))) %>%
  arrange(desc(ecart_moyen))
```
Checking correlation with relationship
```{r}

real_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(relationship, occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(relationship) %>%
  mutate(percentage = count/sum(count)*100)

reference_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percentage_ref = count/sum(count)*100)

diff_data <- real_dist %>%
  left_join(reference_dist %>% select(occupation, percentage_ref), 
            by = "occupation") %>%
  mutate(diff = percentage - percentage_ref)

ggplot(diff_data, aes(x = occupation, y = diff, fill = relationship)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  labs(x = "Occupation", 
       y = "Difference (% reel - % theorical)", 
       fill = "relationship",
       title = "Distance from the variables Independance ") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
we can see that the relationship variables outweighs by far the age in regards of influencing the occupation variable.
To satisfy our cut=riosity, let's test one last variable : sex
```{r}

real_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(sex, occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(sex) %>%
  mutate(percentage = count/sum(count)*100)

reference_dist <- df %>%
  filter(!is.na(occupation)) %>%
  group_by(occupation) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percentage_ref = count/sum(count)*100)

diff_data <- real_dist %>%
  left_join(reference_dist %>% select(occupation, percentage_ref), 
            by = "occupation") %>%
  mutate(diff = percentage - percentage_ref)

ggplot(diff_data, aes(x = occupation, y = diff, fill = sex)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  labs(x = "Occupation", 
       y = "Difference (% reel - % theorical)", 
       fill = "sex",
       title = "Distance from the variables Independance ") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

mean_diff_sex <- diff_data %>%
  group_by(sex) %>%
  summarise(ecart_moyen = mean(abs(diff))) %>%
  arrange(desc(ecart_moyen))
```
So the sex does have an important role on occupation ! Which variables do we we chose now to profile our occupation-missing subjects ?
To be sure, let's mesure the average distance from decorrelation(or Independance) for these last 3 variables
```{r}
cat("mean difference from decorrelation (occupation & marital status)",mean(mean_diff_marital_status$ecart_moyen),"\n")
cat("mean difference from decorrelation (occupation & age group)",mean(mean_diff_age_group$ecart_moyen),"\n")
cat("mean difference from decorrelation (occupation & sex)",mean(mean_diff_sex$ecart_moyen))
```
It appears that the 2 most correlated variables of the 3 are marital status and sex so let's profile by that. To do that we need to find what's the most frequent occupation for each couple of (marital status,sex)
```{r}
df=raw_data
dominant_occupation <- df %>%
  filter(workclass!="?")%>%
  group_by(occupation, marital.status, sex) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(marital.status, sex) %>%
  mutate(percentage = count / sum(count) * 100) %>%
  slice_max(order_by = percentage, n = 1, with_ties = FALSE) %>%
  ungroup()%>%
  print()
```

```{r}
fill_occupation <- function(marital_status, Sex) {
  profile_occupation <- dominant_occupation %>%
    filter(marital.status == marital_status, sex == Sex)%>%
    pull(occupation)
  
  return(profile_occupation)
}

df_fully_filled <- df_filled %>%
  rowwise() %>%
  mutate(occupation = ifelse(occupation == "?",fill_occupation(marital.status, sex),occupation)) %>%
  ungroup()

```
```{r}
print(df_fully_filled)
```

```{r}
df_fully_filled %>%
  filter(workclass=="?")
```
## END OF THE ADDITIONAL DATA CLEANING APPROACHES TO ADD TO main.Rmd