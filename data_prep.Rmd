---
title: "main"
author: "Robin VICO"
date: "2025-10-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Step 1: Data Cleaning and Preparation

```{r, include=FALSE}
library(tidyverse)
library(scales)
<<<<<<< HEAD
=======
library(ggplot2)
library(dplyr)
>>>>>>> origin/siméon
```

```{r}
raw_data = read.csv('data/raw/adult.csv')
raw_data %>%
  head() %>%
  print()
```

```{r}
print(raw_data)
```

```{r}
raw_data %>%
  dim() %>%
  print()
```

```{r}
raw_data %>%
  colnames() %>%
  print()
```

```{r}
raw_data %>%
  str() %>%
  print()
```

```{r}
NA_values = raw_data %>%
  filter(workclass=='?'| occupation=='?'| native.country=='?') %>%
  print()
```

```{r}
print(dim(NA_values))
```

```{r}
for (col_name in names(raw_data)) {
  cat("Colonne :", col_name, "\n")
  print(sort(unique(raw_data[[col_name]])))
  cat("\n")
}
```

cleaning missing values in workclass column :

```{r}
raw_data %>%
  count(workclass) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)
```

we notice that the majority of the classes is 'private' -\> shall we set to 'private' all missing values ?

We can try to go further by looking at the most common workclass for each sex, country, age, education, education.num

```{r}
colnames(data)
```

```{r}
raw_data %>% 
  filter(workclass != '?', sex=='Male') %>% 
  count(workclass) %>%
  arrange(desc(n)) %>%
  print()
```

```{r}
raw_data %>% 
  filter(workclass != '?', sex=='Female') %>% 
  count(workclass) %>%
  arrange(desc(n)) %>%
  print()
```

```{r}
raw_data %>% 
  filter(workclass != '?') %>% 
  group_by(age, sex, education, native.country) %>%
  count(workclass) %>%
  arrange(desc(n)) %>%
  print()
```

For the moment we will just replace all the missing values by the most common value

```{r}
most_common_workclasses = raw_data %>%
  count(workclass) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)

most_common_workclass = most_common_workclasses$workclass[1]

cleaned_data = raw_data %>%
  mutate(workclass = recode(workclass, '?' = most_common_workclass))
head(cleaned_data)
```

```{r}
raw_data %>%
  count(occupation) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)
```

for the occupation column we see that there are no occupation that dominate the others, replacing all the missing values by the most common one is not really a good idea. For the moment we will simply drop the lines containing missing value for the occupation column.

```{r}
cleaned_data = cleaned_data %>%
  filter(occupation != '?')
```

```{r}
most_common_native_countries = raw_data %>%
  count(native.country) %>%
  arrange(desc(n)) %>%
  mutate(percentage = n*100/32651)

print(head(most_common_native_countries))
```

```{r}
most_common_native_country = most_common_native_countries$native.country[1]
print(most_common_native_country)
```

for the missing values in the column native.country, we will replace them by the most common attribute, united-states since its the majority of the elements.

```{r}
cleaned_data = cleaned_data %>%
  mutate(native.country = recode(native.country, '?' = most_common_native_country))
head(cleaned_data)
```

Quick check to see if the difference between raw and cleaned data :

```{r}
print(raw_data)
```

```{r}
print(cleaned_data)
```

Summary : We replaced '?' values of workclass and native.country by the most common values of both columns and we dropped the lines containing '?' values in the column occupation.

Now, because we have two look-alike variables, education and education.num, let's check if there's any redundancy.

```{r}
education_check <- cleaned_data %>%
    select(education, education.num)%>%
    distinct() %>%
    arrange(education.num)
print(education_check)
```

After verification, we can confidently conclude that there is a perfect correlation and redundancy between the two variables. Therefore, it is not only acceptable but even preferable to exclude the education variable from our subsequent analysis.

Moreover, education is not the only variable that can be considered unnecessary. Based on our research, the fnlwgt (final weight) variable also does not contribute meaningfully to our predictive task. This variable represents the number of people in the surveyed population who share the same profile. Consequently, it does not help our models determine whether an individual is likely to earn more or less than \$50K per year.

```{r}
cleaned_data <- cleaned_data %>% 
  select(-fnlwgt, -education)
```

```{r}
print(cleaned_data)
```

Categorical variables : Some categorical variables may contain leading or trailing whitespace. Clean these columns.x

```{r}
library(dplyr)
library(stringr)

cols_with_whitespace <- cleaned_data %>%
  summarise(across(where(is.character), ~ any(str_detect(., "^\\s|\\s$"))))

cols_with_whitespace
```

as we see there is no column that contain any leading or trailing whitespace.

# Step 2: Feature Transformation and Engineering

```{r}
cleaned_data <- cleaned_data %>%
  mutate(native.country = ifelse(native.country == "United-States", "USA", "Other"))
  

print(cleaned_data)
```

```{r}
cleaned_data = cleaned_data %>%
  mutate(income = ifelse(income == '>50K', 1, 0))

print(cleaned_data)
```

```{r}
cleaned_data_country_income_age = cleaned_data_grouped_and_income_simplified %>%
  mutate(age.group = case_when(
    age >= 17 & age <= 20 ~ "Young",
    age >= 21 & age <= 59 ~ "Adult",
    age > 59 ~ "Senior",
  ))
print(cleaned_data_country_income_age)
```

```{r}
final_data = cleaned_data_country_income_age %>%
  mutate(net.capital = capital.gain - capital.loss)

print(final_data)
```

# Step 3: Visualization and Exploration

```{r}
over_50k = final_data %>%
  filter(income.simplified == TRUE)
print(over_50k)
```

Income and Education Level : Visualize the proportion of people earning over \$50K for each level of education-num using a bar diagram

```{r}
ggplot(over_50k, aes(x = factor(education.num))) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Proportion of individuals earning > 50K by education level",
    x = "Education number (education.num)",
    y = "Proportion of individuals in the > 50K subset"
  )
```

Work Hours and Income: Compare the distribution of hours-per-week between the two income classes.

```{r}
ggplot(final_data, aes(x = hours.per.week, fill = income)) +
  geom_histogram(bins = 30) + 
  facet_wrap(~ income, scales = "free_y", ncol = 1) + 
  labs(
    title = "Distribution of hours per week, faceted by income class",
    x = "Hours per week",
    y = "Frequency (number of individuals)",
    fill = "Income class"
  )
```

Impact of Marital Status: Visualize the relationship between marital-status and income.

```{r}
sample_marital_status = final_data %>%
  select(marital.status, income)

ggplot(sample_marital_status, aes(x = marital.status, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = percent) +
  labs(
    title = "Impact of marital status on income",
    x = "Marital status",
    y = "Distribution of income class",
    fill = "Income class"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}
sample_age_distrib = final_data %>%
  select(age, income)

ggplot(sample_age_distrib, aes(x = age)) +
  geom_histogram(aes(fill = income), position = "identity") + 
  facet_wrap(~ income, scales = "free_y") + 
  labs(
    title = "Age distribution faceted by the income class",
    x = "Age",
    y = "Number of people",
    fill = "Income class"
  )
```

```{r}
<<<<<<< HEAD
ggplot(final_data, aes(x = relationship, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Proportion of income > 50K by family role/relationship",
    x = "Relationship",
    y = "Proportion of income category",
    fill = "Income level"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
ggplot(final_data, aes(x = marital.status, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  facet_wrap(~ sex) + 
  labs(
    title = "Proportion of income > 50K by marital status and sex",
    x = "Marital status",
    y = "Proportion of income category",
    fill = "Income level"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Supposons que votre variable groupée s'appelle 'native.country.grouped'
ggplot(cleaned_data_grouped, aes(x = native.country.grouped, fill = income)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Proportion of high income by native country (US vs other)",
    x = "Native country (grouped)",
    y = "Proportion of income category",
    fill = "Income level"
  )
```
=======
print(final_data)
write.csv(final_data,"data/processed/clean_v1.csv")
```
Now that the data preparation is done as well as the visualisation , we can move on to the modeling but why test the model on only one type of cleaned data ? That's the question we asked ourselves. Let's test other ways to clean the data so you can compare afterhand.

Let's see what are the missing variables
```{r}
df=raw_data
na_summary <- sapply(df, function(x) sum(x == "?" | is.na(x)))
na_percentage <- na_summary / nrow(df) * 100
na_df <- data.frame(variable = names(na_percentage), pourcentage_NA = na_percentage)
print(na_df%>%filter(pourcentage_NA != 0))
```
The missing variables are occupation, workclass and native_country

```{r}
# Préparer les données: convertir en caractère et traiter "?" comme NA
max_categories=20
var="native.country"
  df_tmp <- df
  df_tmp[[var]][df_tmp[[var]] == "?"] <- NA_character_
  # df_tmp[[var]][is.na(df_tmp[[var]])] <- NA_character_
  
  # Calculer les fréquences par catégorie (incl. "NA") puis garder top catégories
  counts_raw <- as.data.frame(table(df_tmp[[var]], useNA = "ifany"), stringsAsFactors = FALSE)
  colnames(counts_raw) <- c("valeur", "frequence")
  top_categories <- head(counts_raw[order(-counts_raw$frequence), "valeur"], max_categories)
  
  # Regrouper les autres catégories en "Autres"
  df_tmp[[var]] <- ifelse(df_tmp[[var]] %in% top_categories, df_tmp[[var]], "Autres")
  
  # Recalculer fréquences et pourcentages
  counts2 <- as.data.frame(table(df_tmp[[var]]), stringsAsFactors = FALSE)
  colnames(counts2) <- c("valeur", "frequence")
  counts2$pourcentage <- counts2$frequence / sum(counts2$frequence) * 100
  
  # Ordre des catégories pour le plot (descendant par pourcentage)
  counts2$valeur <- factor(counts2$valeur, levels = counts2$valeur[order(-counts2$pourcentage)])
  
  # Tracer le barplot en pourcentage
  p <- ggplot(counts2, aes(x = valeur, y = pourcentage, fill = valeur)) +
      geom_col(show.legend = FALSE) +
      geom_text(aes(label = paste0(round(pourcentage, 1), "%")), vjust = -0.5, size = 3) +
      labs(title = paste("Répartition (pourcentage) de", var),
               x = var,
               y = "Pourcentage (%)") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      ylim(0, max(counts2$pourcentage) * 1.12)
  
  print(p)
```

>>>>>>> origin/siméon
